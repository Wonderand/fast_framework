package io.renren.controller;import io.renren.common.utils.Result;import io.renren.service.FileService;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import org.springframework.web.multipart.MultipartFile;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.nio.channels.FileChannel;import java.io.File;import java.nio.channels.WritableByteChannel;/** * @Classname ApiFileUploadController * @Pakage: io.renren.controller * @Author: hzr * @Description TODO * @Date 2024/4/9 16:40 * @Created by 22906 * @Version 1.0.0 */@RestController@RequestMapping("/file")public class ApiFileUploadController {    private static final Logger logger = LoggerFactory.getLogger(ApiFileUploadController.class);    // 假设这些路径已经通过配置文件读取并注入    private String tempFilePath = "E:\\temp";    private String destFilePath = "E:\\renren\\renren-security\\renren-api\\target";    @Autowired    private FileService fileService;    @PostMapping("/upload")    public Result<String> uploadFile(@RequestParam("file") MultipartFile file,                                     @RequestParam("name") String fileName,                                     @RequestParam("total") Integer total,                                     @RequestParam("index") Integer index) {        // 安全性检查（示例）        if (file.isEmpty() || file.getSize() > 10 * 1024 * 1024) { // 假设限制文件大小为10MB            return new Result<String>().error("文件上传失败：文件名不合法或文件大小超过限制");        }        File tempFile = new File(tempFilePath, fileName + "_" + index);        try {            file.transferTo(tempFile);            if (index.equals(total)) {                File destFile = new File(destFilePath, fileName);                try (FileOutputStream outputStream = new FileOutputStream(destFile, true);                     WritableByteChannel outChannel = outputStream.getChannel()) {                    for (int i = 1; i <= total; i++) {                        File partFile = new File(tempFilePath, fileName + "_" + i);                        try (FileInputStream inputStream = new FileInputStream(partFile);                             FileChannel inChannel = inputStream.getChannel()) {                            inChannel.transferTo(0, partFile.length(), outChannel);                        } catch (IOException e) {                            logger.error("文件合并失败: " + e.getMessage());                            break; // 合并出错时中断循环                        }                        if (!partFile.delete()) {                            logger.warn("无法删除临时文件: " + partFile.getAbsolutePath());                        }                    }                } catch (IOException e) {                    logger.error("文件操作失败: " + e.getMessage());                    return new Result<String>().error("文件上传失败：内部错误");                }            }        } catch (IOException e) {            logger.error("文件上传失败: " + e.getMessage());            return new Result<String>().error("文件上传失败：内部错误");        }        return new Result<String>().ok("上传成功");    }    /**     * 分片上传接口     *     * @param fileId    文件唯一标识符     * @param chunkIndex 当前分片索引     * @param totalChunks 总分片数     * @param chunk     当前分片数据（MultipartFile）     * @return 上传结果（HTTP 状态码和简短消息）     *///    @PostMapping("/upload1")//    public Result<String> uploadChunk(//            @RequestParam("fileId") String fileId,//            @RequestParam("chunkIndex") int chunkIndex,//            @RequestParam("totalChunks") int totalChunks,//            @RequestPart("file") MultipartFile chunk,//            HttpServletRequest request) {////        // 可以添加额外的校验逻辑，如检查文件ID是否存在、分片索引是否有效等////        // 调用文件服务进行分片上传处理//        boolean success = fileService.saveChunk(fileId, chunkIndex, totalChunks, chunk, request);////        if (success) {////            return new Result.ok("Chunk uploaded successfully.");//            return new Result<>().ok("");//        } else {//            return new Result<>().ok(HttpStatus.INTERNAL_SERVER_ERROR)//        }//        return null;//    }    // 安全性检查：文件名检查示例（需根据实际情况定制）    private boolean isValidFileName(String fileName) {//        apache-tomcat-9.0.82.tar.gz        // 示例：仅允许字母、数字、下划线和点        return fileName.matches("[a-zA-Z0-9_\\.]+");    }}